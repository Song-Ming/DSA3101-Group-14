# -*- coding: utf-8 -*-
"""k-means pt 2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1UOOmHG1cfKG9kcKfqNqaxI7ljZkpJ5_6
"""

import pandas as pd
import matplotlib.pyplot as plt
from sklearn.preprocessing import LabelEncoder, StandardScaler
from sklearn.cluster import KMeans
from sklearn.decomposition import PCA

file_path = "bank_marketing_dataset.csv"
df = pd.read_csv(file_path)

# Drop the duration column
df_cleaned = df.drop(columns=['duration'])

# Handle unknown values by treating them as a separate category
categorical_cols = ['job', 'marital', 'education', 'default', 'housing', 'loan', 'contact', 'month', 'day_of_week', 'poutcome']
for col in categorical_cols:
    df_cleaned[col] = df_cleaned[col].replace('unknown', 'other')

# Encode categorical variables using one hot encoding for better clustering
df_cleaned = pd.get_dummies(df_cleaned, columns=categorical_cols, drop_first=True)

# Convert subscribed variable to binary (0 = no, 1 = yes)
df_cleaned['subscribed'] = df_cleaned['subscribed'].map({'no': 0, 'yes': 1})

# Create a copy of the DataFrame for later visualisations of clusters
df_unscaledcopy = df_cleaned.copy()


# Normalise numerical variables
numerical_cols = ['age', 'campaign', 'pdays', 'previous', 'emp.var.rate', 'cons.price.idx',
                  'cons.conf.idx', 'euribor3m', 'nr.employed']

scaler = StandardScaler()
df_cleaned[numerical_cols] = scaler.fit_transform(df_cleaned[numerical_cols])


df_cleaned.to_csv("preprocessed_bank_marketing.csv", index=False)

# Define range for potential cluster numbers
wcss = []
K_range = range(2, 11)  # Checking clusters from 2 to 10

# k-means for each k and compute wcss
for k in K_range:
    kmeans = KMeans(n_clusters=k, random_state=42, n_init=10)
    kmeans.fit(df_cleaned)
    wcss.append(kmeans.inertia_)

# Plot Elbow Method graph
plt.figure(figsize=(8, 5))
plt.plot(K_range, wcss, marker='o', linestyle='-')
plt.xlabel('Number of Clusters (K)')
plt.ylabel('WCSS (Within-Cluster Sum of Squares)')
plt.title('Elbow Method for Optimal K')
plt.show()

# Apply KMeans clustering with k=3
k = 3
kmeans = KMeans(n_clusters=k, random_state=42, n_init=10)
df_cleaned['cluster'] = kmeans.fit_predict(df_cleaned)
df_unscaledcopy['cluster']=df_cleaned['cluster'] ##for visualisation of clusters

# Perform PCA to reduce the data to 2 components for visualisation
pca = PCA(n_components=2)
reduced_data = pca.fit_transform(df_cleaned.drop(columns=['subscribed', 'cluster']))

plt.figure(figsize=(10, 8))
plt.scatter(reduced_data[:, 0], reduced_data[:, 1], c=df_cleaned['cluster'], cmap='viridis', alpha=0.6)
plt.title(f'KMeans Clustering with k={k} (PCA-reduced data)')
plt.xlabel('Principal Component 1')
plt.ylabel('Principal Component 2')
plt.colorbar(label='Cluster')
plt.show()

cluster_means = df_cleaned.groupby('cluster').mean()
print(cluster_means)

import pandas as pd

pd.set_option('display.max_columns', None)
print(cluster_means)

import seaborn as sns
import matplotlib.pyplot as plt
plt.figure(figsize=(10, 6))
sns.histplot(data=df_unscaledcopy, x='age', hue='cluster', kde=True, bins=30, palette='Set1')
plt.title('Age Distribution Across Clusters')
plt.xlabel('Age')
plt.ylabel('Frequency')
plt.show()
##age in clusters are more or less similar, which 30-40 being the majority, cluster 1 of a slightly younger age

print(df_unscaledcopy.head())

import pandas as pd
import matplotlib.pyplot as plt

job_columns = [col for col in df_unscaledcopy.columns if 'job_' in col]
job_distribution = df_unscaledcopy.groupby('cluster')[job_columns].sum()
job_distribution_proportions = job_distribution.div(job_distribution.sum(axis=1), axis=0)
job_distribution_proportions.plot(kind='bar', stacked=True, figsize=(12, 6),colormap='Set3') ##proportion easier to compare because clusters are of different size
plt.title('Proportion of Job Types by Cluster')
plt.xlabel('Cluster')
plt.ylabel('Proportion')
plt.xticks(rotation=0)
plt.legend(title='Job Types', bbox_to_anchor=(1.05, 1), loc='upper left')

plt.tight_layout()
plt.show()
##cluster 2 has the most number of unemployed and student as well as retired, thus might opt for low-risk saving plans/basic financial products like fixed deposits
##both cluster 0 and 1 are made mainly blue collar workers and technicians, but cluster 1 is more diverse in terms of job distribution, thus more flexible marketing campaigns can be targeted at this group,
#while cluster 0 has stable income but less high-income opportunity, thus basic financial products, focusing on affordability and financial security might be more suitable.

##cluster 2 has highest rate of success for previous campaigns, while most of cluster 1 was not contacted

subscribed_proportion = df_unscaledcopy.groupby(['cluster', 'subscribed']).size().unstack()
subscribed_proportion = subscribed_proportion.div(subscribed_proportion.sum(axis=1), axis=0)
subscribed_proportion.plot(kind='bar', stacked=False, figsize=(8, 6), color=['#FF9999', '#66B3FF'])
plt.title('Subscribed Proportion by Cluster')  ##proportion for easier comparison
plt.xlabel('Cluster')
plt.ylabel('Proportion')
plt.legend(title='Subscription Status', loc='upper right')
plt.xticks(rotation=0)
plt.show()
##higher proportion of cluster 2 subscribed to term deposit, revealing their interests in more financial secure campaigns, while cluster 0 has higher proportion of engagement than cluster 1

##Cluster 0: A middle-aged group with a slightly larger age range and stable income, but fewer high-paying jobs. This group shows moderate engagement in low-risk financial products like term deposits. They were not targeted in previous campaigns.
##Cluster 1: Middle-aged individuals with diverse jobs, including those from higher socio-economic statuses, with low subscription to term deposits. This group was not targeted in previous campaigns but can be targeted in future marketing campaigns.
##Cluster 2: A diverse group with many students and retired individuals. They may opt for low-risk financial products and have shown high engagement in term deposits. This group was targeted in previous campaigns and has had high success rates.